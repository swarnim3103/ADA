# Analysis and Design of Algorithms (ADA)


##  Algorithm Checklist

###  Sorting Algorithms
- [x] **Merge Sort** – Implements the Merge Sort algorithm.
>
- [x] **Quick Sort** – Implements the Quick Sort algorithm.
>

###  Divide and Conquer
- [x] **Convex Hull** – Implements the Convex Hull algorithm using the Divide and Conquer approach.
> - QuickHull is a divide-and-conquer algorithm that finds the convex hull by:
> - Starting with the leftmost and rightmost points, recursively finding the farthest outer points, discarding interior ones, and combining outer points to form the convex boundary.
- [x] **Matrix Multiplication** – Performs matrix multiplication using the Divide and Conquer technique.
> - Matrix Multiplication (Divide and Conquer) splits two matrices into submatrices, recursively multiplies them, and combines the results to form the final product.It reduces large matrix multiplication into smaller ones for better efficiency, especially useful for large square matrices.
- [x] **Peak Finding** – Finds a peak element in a 1D or 2D array using binary search.
> - Peak Finding (1D/2D using Binary Search) locates an element that is greater than or equal to its neighbors by repeatedly dividing the array (or matrix) and checking mid elements.
> -It uses binary search to efficiently find a peak in O(log n) (1D) or O(n log m) (2D) time.
###  Greedy Algorithms
- [x] **Fractional Knapsack** – Solves the Knapsack problem allowing fractional item inclusion.
> - Fractional Knapsack solves the knapsack problem by sorting items by value-to-weight ratio and greedily taking as much of the highest ratio items as possible — including fractions — to maximize profit.
- [x] **Prim's Algorithm** – Finds the Minimum Spanning Tree using Prim's approach.
> - Prim’s Algorithm builds a Minimum Spanning Tree by starting from any node and repeatedly adding the smallest edge that connects a new vertex to the growing tree, until all vertices are included.
- [x] **Kruskal's Algorithm** – Constructs the Minimum Spanning Tree using Kruskal's method.
- [x] **Dijkstra's Algorithm** – Computes the shortest path from a single source to all vertices in a graph.

###  Dynamic Programming
- [x] **Longest Common Subsequence (LCS)** – Computes the longest subsequence common to two sequences.
- [x] **Matrix Chain Multiplication** – Determines the most efficient way to multiply a sequence of matrices.
- [x] **All-Pairs Shortest Path (Floyd-Warshall)** – Finds shortest paths between all pairs of vertices in a weighted graph.
- [x] **0/1 Knapsack** – Solves the 0/1 Knapsack problem using dynamic programming.
- [x] **Multistage Graph (Forward Approach)** – Finds the shortest path in a multistage graph using a forward approach.
- [x] **Multistage Graph (Backward Approach)** – Determines the shortest path in a multistage graph using a backward approach.

###  Backtracking
- [ ] **N-Queens Problem** – Solves the N-Queens problem using backtracking.
- [ ] **Subset Sum Problem** – Determines if there's a subset with a sum equal to a given number.
- [ ] **m-color graph**
- [ ] **Hamiltonian Cycle**




